var H=Object.defineProperty,M=Object.defineProperties;var q=Object.getOwnPropertyDescriptors;var S=Object.getOwnPropertySymbols;var N=Object.prototype.hasOwnProperty,A=Object.prototype.propertyIsEnumerable;var j=(s,e,t)=>e in s?H(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,n=(s,e)=>{for(var t in e||(e={}))N.call(e,t)&&j(s,t,e[t]);if(S)for(var t of S(e))A.call(e,t)&&j(s,t,e[t]);return s},d=(s,e)=>M(s,q(e));var m=(s,e)=>{var t={};for(var r in s)N.call(s,r)&&e.indexOf(r)<0&&(t[r]=s[r]);if(s!=null&&S)for(var r of S(s))e.indexOf(r)<0&&A.call(s,r)&&(t[r]=s[r]);return t};import{derived as T,get as c,writable as P}from"svelte/store";var R=["error","warn","debug"],F=({logger:s=console,level:e=R[1],prefix:t="[i18n]: "})=>R.reduce((r,a,o)=>d(n({},r),{[a]:i=>R.indexOf(e)>=o&&s[a](`${t}${i}`)}),{}),l=F({}),V=s=>{l=s};var O=g=>{var u=g,{parser:s,key:e,params:t,translations:r,locale:a,fallbackLocale:o}=u,i=m(u,["parser","key","params","translations","locale","fallbackLocale"]);if(!(e&&a))return l.warn("No translation key or locale provided. Skipping translation..."),"";let p=(r[a]||{})[e];return o&&p===void 0&&(p=(r[o]||{})[e]),i.hasOwnProperty("fallbackValue")&&p===void 0?i.fallbackValue:s.parse(p,t,a,e)},f=(...s)=>s.length?s.filter(e=>!!e).map(e=>{let t=`${e}`.toLowerCase();try{let[r]=Intl.Collator.supportedLocalesOf(e);if(!r)throw new Error(`'${e}' is non-standard.`);t=r}catch(r){l.warn(`Non-standard locale provided: '${e}'. Check your 'translations' and 'loaders' in i18n config...`)}return t}):[],w=(s,e)=>Object.keys(s||{}).reduce((t,r)=>{let a=s[r],o=e?`${e}.${r}`:`${r}`;return a&&typeof a=="object"?n(n({},t),w(a,o)):d(n({},t),{[o]:a})},{}),$=async s=>{try{return(await Promise.all(s.map(a=>{var o=a,{loader:t}=o,r=m(o,["loader"]);return new Promise(async i=>{let g;try{g=await t()}catch(u){l.error(`Failed to load translation. Verify your '${r.locale}' > '${r.key}' Loader.`),l.error(u)}i(d(n({loader:t},r),{data:g}))})}))).reduce((t,{key:r,data:a,locale:o})=>{if(!a)return t;let[i]=f(o);return d(n({},t),{[i]:w(d(n({},t[i]||{}),{[r]:a}))})},{})}catch(e){l.error(e)}return{}},E=s=>e=>{try{if(typeof e=="string")return e===s;if(typeof e=="object")return e.test(s)}catch(t){l.error("Invalid route config!")}return!1},W=(s,e)=>{let t=!0;try{t=Object.keys(s).filter(r=>s[r]!==void 0).every(r=>s[r]===e[r])}catch(r){}return t};var D=1e3*60*60*24,z=class{constructor(e){this.cachedAt=0;this.loadedKeys={};this.currentRoute=P();this.config=P();this.isLoading=P(!1);this.promises=new Set;this.loading={subscribe:this.isLoading.subscribe,toPromise:(e,t)=>{let r=Array.from(this.promises).filter(a=>W({locale:f(e)[0],route:t},a)).map(({promise:a})=>a);return Promise.all(r)},get:()=>c(this.isLoading)};this.privateTranslations=P({});this.translations={subscribe:this.privateTranslations.subscribe,get:()=>c(this.translations)};this.locales=d(n({},T([this.config,this.privateTranslations],([e,t])=>{if(!e)return[];let{loaders:r=[]}=e,a=r.map(({locale:i})=>i),o=Object.keys(t).map(i=>i);return Array.from(new Set([...f(...a),...f(...o)]))},[])),{get:()=>c(this.locales)});this.internalLocale=P();this.loaderTrigger=T([this.internalLocale,this.currentRoute],([e,t],r)=>{var a,o;e!==void 0&&t!==void 0&&!(e===((a=c(this.loaderTrigger))==null?void 0:a[0])&&t===((o=c(this.loaderTrigger))==null?void 0:o[1]))&&(l.debug("Triggering translation load..."),r([e,t]))},[]);this.localeHelper=P();this.locale={subscribe:this.localeHelper.subscribe,forceSet:this.localeHelper.set,set:this.internalLocale.set,update:this.internalLocale.update,get:()=>c(this.locale)};this.initialized=T([this.locale,this.currentRoute,this.privateTranslations],([e,t,r],a)=>{c(this.initialized)||a(e!==void 0&&t!==void 0&&!!Object.keys(r).length)});this.translation=T([this.privateTranslations,this.locale,this.isLoading],([e,t,r],a)=>{let o=e[t];o&&Object.keys(o).length&&!r&&a(o)},{});this.t=d(n({},T([this.config,this.translation],a=>{var[o]=a,i=o,{parser:e,fallbackLocale:t}=i,r=m(i,["parser","fallbackLocale"]);return(g,...u)=>O(n({parser:e,key:g,params:u,translations:this.translations.get(),locale:this.locale.get(),fallbackLocale:t},r.hasOwnProperty("fallbackValue")?{fallbackValue:r.fallbackValue}:{}))})),{get:(e,...t)=>c(this.t)(e,...t)});this.l=d(n({},T([this.config,this.translations],o=>{var[i,...g]=o,u=i,{parser:e,fallbackLocale:t}=u,r=m(u,["parser","fallbackLocale"]),[a]=g;return(p,v,...k)=>O(n({parser:e,key:v,params:k,translations:a,locale:p,fallbackLocale:t},r.hasOwnProperty("fallbackValue")?{fallbackValue:r.fallbackValue}:{}))})),{get:(e,t,...r)=>c(this.l)(e,t,...r)});this.getLocale=e=>{let{fallbackLocale:t=""}=c(this.config)||{},r=e||t;if(!r)return"";let a=this.locales.get();return a.find(i=>f(r).includes(i))||a.find(i=>f(t).includes(i))||""};this.setLocale=e=>{if(e&&e!==c(this.internalLocale))return l.debug(`Setting '${e}' locale.`),this.internalLocale.set(e),this.loading.toPromise(e,c(this.currentRoute))};this.setRoute=e=>{if(e!==c(this.currentRoute)){l.debug(`Setting '${e}' route.`),this.currentRoute.set(e);let t=c(this.internalLocale);return this.loading.toPromise(t,e)}};this.loadConfig=async e=>{await this.configLoader(e)};this.getTranslationProps=async(e=this.locale.get(),t=c(this.currentRoute))=>{let r=c(this.config);if(!r||!e)return[];let a=this.translations.get(),{loaders:o,fallbackLocale:i="",cache:g=D}=r||{},u=Number.isNaN(+g)?D:+g;this.cachedAt?Date.now()>u+this.cachedAt&&(l.debug("Refreshing cache."),this.loadedKeys={},this.cachedAt=0):(l.debug("Setting cache timestamp."),this.cachedAt=Date.now());let[p,v]=f(e,i),k=a[p],I=a[v],C=(o||[]).map(K=>{var L=K,{locale:h}=L,b=m(L,["locale"]);return d(n({},b),{locale:f(h)[0]})}).filter(({routes:h})=>!h||(h||[]).some(E(t))).filter(({key:h,locale:b})=>b===p&&(!k||!(this.loadedKeys[p]||[]).includes(h))||i&&b===v&&(!I||!(this.loadedKeys[v]||[]).includes(h)));if(C.length){this.isLoading.set(!0),l.debug("Fetching translations...");let h=await $(C);this.isLoading.set(!1);let b=Object.keys(h).reduce((L,y)=>d(n({},L),{[y]:Object.keys(h[y])}),{}),K=C.filter(({key:L,locale:y})=>(b[y]||[]).some(x=>`${x}`.startsWith(L))).reduce((L,{key:y,locale:x})=>d(n({},L),{[x]:[...L[x]||[],y]}),{});return[h,K]}return[]};this.addTranslations=(e,t)=>{if(!e)return;l.debug("Adding translations...");let r=Object.keys(e||{});this.privateTranslations.update(a=>r.reduce((o,i)=>d(n({},o),{[i]:n(n({},o[i]||{}),w(e[i]))}),a)),r.forEach(a=>{let o=Object.keys(e[a]).map(i=>`${i}`.split(".")[0]);t&&(o=t[a]),this.loadedKeys[a]=Array.from(new Set([...this.loadedKeys[a]||[],...o||[]]))})};this.loader=async([e,t])=>{let r=this.getLocale(e);l.debug(`Adding loader promise for '${r}' locale and '${t}' route.`);let a=(async()=>{let o=await this.getTranslationProps(r,t);o.length&&this.addTranslations(...o)})();this.promises.add({locale:r,route:t,promise:a}),a.then(()=>{r&&this.locale.get()!==r&&this.locale.forceSet(r)})};this.loadTranslations=(e,t=c(this.currentRoute)||"")=>{let r=this.getLocale(e);if(r)return this.setRoute(t),this.setLocale(r),this.loading.toPromise(r,t)};this.loaderTrigger.subscribe(this.loader),this.isLoading.subscribe(async t=>{t&&this.promises.size&&(await this.loading.toPromise(),this.promises.clear(),l.debug("Loader promises have been purged."))}),e&&this.loadConfig(e)}async configLoader(e){if(!e)return l.error("No config provided!");let g=e,{initLocale:t,fallbackLocale:r,translations:a,log:o}=g,i=m(g,["initLocale","fallbackLocale","translations","log"]);o&&V(F(o)),[t]=f(t),[r]=f(r),l.debug("Setting config."),this.config.set(n({initLocale:t,fallbackLocale:r,translations:a},i)),a&&this.addTranslations(a),await this.loadTranslations(t)}};export{z as default};
